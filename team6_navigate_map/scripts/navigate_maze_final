#!/usr/bin/env python

############################################################
# navigate_maze node: navigates the turtle bot through 
# waypoints in a maze using machine learning to classify
# signs 
############################################################

import rospy
import numpy as np
import actionlib

from enum import Enum
from tf2_ros import *
import tf
from tf.transformations import *

from geometry_msgs.msg import *
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from actionlib_msgs.msg import GoalStatus
from sensor_msgs.msg import LaserScan
from std_msgs.msg import Byte

from pid import PID


BURGER_MAX_ANG_VEL = 2.84
BURGER_MAX_LIN_VEL = 0.2

class NavController:
	def __init__(self, pos_tol, yaw_tol, ang_vel_min_max, lin_vel_min_max):
		self.pos_tol, self.yaw_tol = pos_tol, yaw_tol
		
		# amcl subscription
		self.global_pose = PoseStamped()
		self.amcl_sub = rospy.Subscriber("/amcl_pose", PoseWithCovarianceStamped, self.amcl_callback)
		rospy.wait_for_message("/amcl_pose", PoseWithCovarianceStamped)

		# transform
		self.tf_buffer = Buffer()
		self.tf_listener = tf.TransformListener(self.tf_buffer)
		self.tf_listener.waitForTransform('/map','/base_link',rospy.Time(), rospy.Duration(4.0))

		# create controllers
		self.ang_controller = PID(1.7, 0, 0, ang_vel_min_max[1], ang_vel_min_max[0])
		self.lin_controller = PID(0.8, 0, 0, lin_vel_min_max[1], lin_vel_min_max[0])

		self.cmd_vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size = 10)


	def amcl_callback(self, amcl):
		self.global_pose.header = amcl.header 
		self.global_pose.pose = amcl.pose.pose
	
	def transform2local(self, waypoint):
		result = PoseStamped()

		# extract global position data
		wp_global_position = waypoint.target_pose.pose.position
		turtle_global_position = self.global_pose.pose.position

		wp_global_position = np.array([wp_global_position.x, wp_global_position.y, wp_global_position.z])
		turtle_global_position = np.array([turtle_global_position.x, turtle_global_position.y, turtle_global_position.z])

		# extract global orientation data 
		wp_orient = waypoint.target_pose.pose.orientation
		turtle_orient = self.global_pose.pose.orientation

		wp_orient = [wp_orient.x, wp_orient.y, wp_orient.z, wp_orient.w]
		turtle_orient = [turtle_orient.x, turtle_orient.y, turtle_orient.z, turtle_orient.w]

		# transform
		rot_mat = quaternion_matrix(turtle_orient)
		trans_mat = translation_matrix(turtle_global_position)
		rob_mat = concatenate_matrices(trans_mat, rot_mat)

		foo = np.append(wp_global_position, 1)
		trans = np.dot(np.linalg.inv(rob_mat), np.transpose(foo))[0:3]

		# find waypoint orientation in rob frame
		inv_rob_quat = quaternion_conjugate(turtle_orient)
		new_quat = quaternion_multiply(inv_rob_quat, wp_orient)

		result.pose.position = Point(x=trans[0], y=trans[1], z=trans[2])
		result.pose.orientation = Quaternion(x=new_quat[0], y=new_quat[1], z=new_quat[2], w=new_quat[3])

		return result

	def transform2localv2(self, waypoint):	
		waypoint.target_pose.header.frame_id = '/map'
		waypoint.target_pose.header.stamp = rospy.Time(0)

		transformed = self.tf_listener.transformPose('/base_footprint', waypoint.target_pose)
		print(transformed)
		return transformed	
			
	
	def ControlHeading(self, waypoint):
		heading_thresh = 0.035 # rad
		heading_met = False

		control_output = Twist()
		while (not heading_met):
			target_pos_local = self.transform2localv2(waypoint)
			target_position = target_pos_local.pose.position
			print(target_position)

			heading = np.arctan2(target_position.y, target_position.x)

			ang_vel = self.ang_controller.Calculate(0.1, heading, 0)
			lin_vel = 0

			control_output.angular.z, control_output.linear.x = ang_vel, lin_vel
			self.cmd_vel_pub.publish(control_output)
			heading_met = True if abs(heading) < self.yaw_tol else False

		control_output.angular.z, control_output.linear.x = 0, 0
		self.cmd_vel_pub.publish(control_output)

	def ControlPosition(self, waypoint):
		position_met = False

		control_output = Twist()
		while (not position_met):
			target_pos_local = self.transform2localv2(waypoint)
			target_position = target_pos_local.pose.position
			error_mag = np.sqrt(target_position.x**2 + target_position.y**2)

			heading = np.arctan2(target_position.y, target_position.x)
			
			if error_mag > 2*self.pos_tol:
				ang_vel = self.ang_controller.Calculate(0.01, heading, 0)
			else:
				ang_vel = 0
			
			lin_vel = self.lin_controller.Calculate(0.01, target_position.x, 0)

			control_output.angular.z, control_output.linear.x = ang_vel, lin_vel
			self.cmd_vel_pub.publish(control_output)

			position_met = True if error_mag < self.pos_tol else False

		control_output.angular.z, control_output.linear.x = 0, 0
		self.cmd_vel_pub.publish(control_output)

	def ControlOrient(self, waypoint):
		orient_met = False

		control_output = Twist()
		while (not orient_met):
			target_pos_local = self.transform2localv2(waypoint)
			target_orient = target_pos_local.pose.orientation
			quat = np.array([target_orient.x, target_orient.y, target_orient.z, target_orient.w])
			
			[_, _, yaw] = euler_from_quaternion(quat)

			ang_vel = self.ang_controller.Calculate(0.01, yaw, 0)
			lin_vel = 0

			control_output.angular.z, control_output.linear.x = ang_vel, lin_vel
			self.cmd_vel_pub.publish(control_output)

			orient_met = True if abs(yaw) < self.yaw_tol else False

		control_output.angular.z, control_output.linear.x = 0, 0
		self.cmd_vel_pub.publish(control_output)


	def Navigate(self, waypoint):
		#position_met, orient_met = False, False 

		self.ControlHeading(waypoint)
		self.ControlPosition(waypoint)
		self.ControlOrient(waypoint)

		

class Navigator:
	def __init__(self):
		self.move_base = actionlib.SimpleActionClient('move_base', MoveBaseAction)
		self.move_base.wait_for_server()

	def _SetHeader(self, goal):
		goal.target_pose.header.stamp = rospy.Time.now()
		goal.target_pose.header.frame_id = "map"
		return goal

	def Navigate(self, waypoint):
		current_waypoint = self._SetHeader(waypoint)
		
		rospy.loginfo("Current Goal:")
		rospy.loginfo(current_waypoint)
		
		self.move_base.send_goal(current_waypoint)	
		success = self.move_base.wait_for_result(rospy.Duration(60))
		state = self.move_base.get_state()
		
		if success and state == GoalStatus.SUCCEEDED:
			rospy.loginfo(self.move_base.get_goal_status_text)
		else:
			rospy.loginfo(self.move_base.get_goal_status_text)
			self.move_base.cancel_goal()
			rospy.logerr("Did not reach goal... exiting")
		
		return success

class Waypoint2D(MoveBaseGoal):
	def __init__(self, pos, orient):
		waypoint = PoseStamped()
			
		pos = Point(pos[0], pos[1], 0)
		orient = Quaternion(orient[0], orient[1], orient[2], orient[3])

		waypoint.pose.position, waypoint.pose.orientation = pos, orient
		self.target_pose = waypoint

class GridMap:
	class Direction(Enum):
		RIGHT, LEFT, BACKWARD, FORWARD = 0, 1, 2, 3

	class Cardinal(Enum):
		NORTH, EAST, SOUTH, WEST = 0, 1, 2, 3

		def CW(cardinal):
			return GridMap.Cardinal((cardinal.value + 1) % 4)

		def CCW(cardinal):
			return GridMap.Cardinal((cardinal.value - 1) % 4)

		def BACK(cardinal):
			return GridMap.Cardinal((cardinal.value + 2) % 4)

	# cardinal2quaternion lookup table
	# index with Cardinal (NESW) to get Quaternion
	card2quat = [(0, 0, 0, 1), 
			 	 (0, 0, -0.7071068, 0.7071068),
			 	 (0, 0, 1, 0),
			 	 (0, 0, 0.7071068, 0.7071068)]

	# maps a commanded direction + current orientation --> increments (x, y)
	# increment_map[Direction, Cardinal]  
	increment_map = [[( 0, 1), ( 1, 0), ( 0,-1), (-1, 0)],
				 	 [( 0,-1), (-1, 0), ( 0, 1), ( 1, 0)], 
				 	 [( 1, 0), ( 0,-1), (-1, 0), ( 0, 1)],
				 	 [(-1, 0), ( 0, 1), ( 1, 0), ( 0,-1)]]

	def __init__(self, init_pose, init_orient):
		#maxx = 3.3 maxy = 0.6
		self.GCx = np.linspace(3.3, 0.3, 6)
		self.GCy = np.linspace(0.6, -0.6, 3)
		#self.GCx = np.linspace(3.7, -0.75, 6)
		#self.GCy = np.linspace(0.9, -1, 3)

		self._localize(init_pose, init_orient)

	def _localize(self, init_pose, init_orient):
		init_pose = np.array(init_pose)
		init_orient = np.array(init_orient)

		# find location
		(mini, minj) = (0, 0)
		min_dist = 100
		for i in range(np.size(self.GCx)):
			for j in range(np.size(self.GCy)):
				pose = np.array([self.GCx[i], self.GCy[j]])
				norm = np.linalg.norm(pose - init_pose)
				if norm < min_dist:
					(mini, minj) = (i, j)
					min_dist = norm

		self.index = (mini, minj)

		# find orientation
		mini = 0
		min_dist = 100
		for i in range(len(GridMap.card2quat)):
			orient = np.array(GridMap.card2quat[i])
			
			norm = np.linalg.norm(orient - init_orient)
			if norm < min_dist:
				mini = i
				min_dist = norm

		self.dir = GridMap.Cardinal(mini)

	def update_index(self, direction):
		inc_x, inc_y = GridMap.increment_map[direction.value][self.dir.value]

		potential_x, potential_y = self.index
		potential_x += inc_x
		potential_y += inc_y

		# prevent overflow
		if (not np.size(self.GCx) - potential_x <=0):
			self.index = (potential_x, self.index[1])
		if (not np.size(self.GCy) - potential_y <=0):
			self.index = (self.index[0], potential_y)

	def globalpose(self):
		x = self.GCx[self.index[0]]
		y = self.GCy[self.index[1]]
		orient = GridMap.card2quat[self.dir.value]
		return ((x, y), orient)

	def right(self):
		#self.update_index(GridMap.Direction.RIGHT)
		self.dir = GridMap.Cardinal.CW(self.dir)

	def left(self):
		#self.update_index(GridMap.Direction.LEFT)
		self.dir = GridMap.Cardinal.CCW(self.dir)

	def forward(self):
		self.update_index(GridMap.Direction.FORWARD)

	def backward(self):
		self.update_index(GridMap.Direction.BACKWARD)
		self.dir = GridMap.Cardinal.BACK(self.dir)

class Lidar:
	def __init__(self):
		#self._twist = Twist()
		self.wall_status = 1

		self.lidar_sub = rospy.Subscriber("/scan", LaserScan, self.LidarCallback, queue_size=10)
		#self._vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size = 10)

	def LidarCallback(self, lidar_data):
		pause = False
		min_distance = self.parse_distances(lidar_data)
		self.wall_status = self.check_for_wall(min_distance)
		
		if pause:
			rospy.sleep(10)	

	def check_for_wall(self, min_distance, distance_thresh=0.7): #is there a wall or empty block in front of us?
		if min_distance>distance_thresh:
			wall_status = 0 #there is not a wall in front of us
		else:
			wall_status = 1 #there is a wall in front of us

		return wall_status

	def parse_distances(self, lidar_data, heading=0):
		HEADING_THRESH=10

	#		try:
		heading_range = np.array(range(int(heading) - HEADING_THRESH, 
									int(heading) + HEADING_THRESH + 1))

		## wrap angles
		lidar_ang = heading_range % 360		
		lidar_ang = (lidar_ang + 360) % 360 # force positive 

		lidar_ang = [ang-360 if ang > 180 else ang for ang in lidar_ang]

		dists = [lidar_data.ranges[i] for i in lidar_ang]
		filtered_dists=[]
		for point in dists:
			point = 1000 if point == 0 else point
			filtered_dists.append(point)

		min_dist = np.min(filtered_dists)

		return min_dist

class Executor:
	def __init__(self):
		self.lidar_sub = Lidar()

		# initialize map
		current_pos = rospy.wait_for_message("/amcl_pose", PoseWithCovarianceStamped)
		
		initpos = current_pos.pose.pose.position
		initorient = current_pos.pose.pose.orientation
		
		initpos = (initpos.x, initpos.y)
		initorient = (initorient.x, initorient.y, initorient.z, initorient.w)

		self.grid_map = GridMap(initpos, initorient)
		#print(self.grid_map.index)

		self.label_map = {0: 'empty_wall', 1: 'left', 2: 'right',
						  3: 'do not enter', 4: 'stop', 5: 'goal'}

		# create navigator
		ang_vel_min_max = (-BURGER_MAX_ANG_VEL, BURGER_MAX_ANG_VEL)
		lin_vel_min_max = (-BURGER_MAX_LIN_VEL, BURGER_MAX_LIN_VEL)
		self.nav = NavController(0.01, 0.034, ang_vel_min_max, lin_vel_min_max)

	def execute(self):
		# check for wall
		if not self.lidar_sub.wall_status: # no wall
			self.grid_map.forward()
			pose, orient = self.grid_map.globalpose()
			waypoint = Waypoint2D(pose, orient)

		else:
			rospy.sleep(1)
			sign_type = rospy.wait_for_message('/classified_image', Byte)
			sign_type = self.label_map[sign_type.data]

			rospy.loginfo("=============" + sign_type + "==============")

			if (sign_type == 'empty_wall'): 	 # try again next iteration
				waypoint = None
			else:								 # we found a sign
				if (sign_type == 'right'):
					self.grid_map.right()
				elif (sign_type == 'left'):
					self.grid_map.left()
				elif (sign_type == 'do not enter'):
					self.grid_map.backward()
				elif (sign_type == 'stop'):
					self.grid_map.backward()
				elif (sign_type == 'goal'):
					rospy.loginfo('YOU DONT SUCK')

				pose, orient = self.grid_map.globalpose()
				waypoint = Waypoint2D(pose, orient)
		
		if not waypoint == None:
			self.nav.Navigate(waypoint)
		
		
if __name__=='__main__':
	rospy.init_node('navigate_maze_final', anonymous=False)

	#pos = (0.9, 0.0)
	#orient = (0, 0, 0, 1)

	#waypoint = Waypoint2D(pos, orient)

	try:
		#ang_vel_min_max = (-BURGER_MAX_ANG_VEL, BURGER_MAX_ANG_VEL)
		#lin_vel_min_max = (-BURGER_MAX_LIN_VEL, BURGER_MAX_LIN_VEL)

		#test = NavController(0.01, 0.034, ang_vel_min_max, lin_vel_min_max)
		
		#while (not rospy.is_shutdown()):
		#test.Navigate(waypoint)

		exec_test = Executor()

		while (not rospy.is_shutdown()):
			exec_test.execute()

	except rospy.ROSInterruptException:
		pass