#!/usr/bin/env python

############################################################
# navigate_maze node: navigates the turtle bot through 
# waypoints in a maze using machine learning to classify
# signs 
############################################################

import rospy
import numpy as np
import actionlib

from enum import Enum
from tf2_ros import *
import tf
from tf.transformations import *

from geometry_msgs.msg import *
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from actionlib_msgs.msg import GoalStatus
from sensor_msgs.msg import LaserScan
from std_msgs.msg import Byte

from pid import PID


BURGER_MAX_ANG_VEL = 2.84
BURGER_MAX_LIN_VEL = 0.2

		
class Navigator:
	def __init__(self):
		self.move_base = actionlib.SimpleActionClient('move_base', MoveBaseAction)
		self.move_base.wait_for_server()

	def _SetHeader(self, goal):
		goal.target_pose.header.stamp = rospy.Time.now()
		goal.target_pose.header.frame_id = "map"
		return goal

	def Navigate(self, waypoint):
		current_waypoint = self._SetHeader(waypoint)
		
		rospy.loginfo("Current Goal:")
		rospy.loginfo(current_waypoint)
		
		self.move_base.send_goal(current_waypoint)	
		success = self.move_base.wait_for_result(rospy.Duration(60))
		state = self.move_base.get_state()
		
		if success and state == GoalStatus.SUCCEEDED:
			rospy.loginfo(self.move_base.get_goal_status_text)
		else:
			rospy.loginfo(self.move_base.get_goal_status_text)
			self.move_base.cancel_goal()
			rospy.logerr("Did not reach goal... exiting")
		
		return success

class NavController:
	def __init__(self, pos_tol, yaw_tol, ang_vel_min_max, lin_vel_min_max):
		self.pos_tol, self.yaw_tol = pos_tol, yaw_tol
		self.lin_vel_min_max = lin_vel_min_max
		
		# transform
		self.tf_buffer = Buffer()
		self.tf_listener = tf.TransformListener(self.tf_buffer)
		self.tf_listener.waitForTransform('/map','/base_link',rospy.Time(), rospy.Duration(4.0))

		# create controllers
		self.ang_controller = PID(1.6, 0, 0, ang_vel_min_max[1], ang_vel_min_max[0])
		self.lin_controller = PID(1.7, 0, 0, lin_vel_min_max[1], lin_vel_min_max[0])

		self.current_lin_vel = 0
		self.lin_accel = 0.005
		self.cmd_vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size = 10)

		self.rate = rospy.Rate(20)

	def transform2local(self, waypoint):	
		waypoint.target_pose.header.frame_id = '/map'
		waypoint.target_pose.header.stamp = rospy.Time(0)

		transformed = self.tf_listener.transformPose('/base_footprint', waypoint.target_pose)
		return transformed	
			
	def create_profile(self, new_vel):
		current = self.current_lin_vel

		accel = new_vel - current
		out = new_vel
		
		if accel > 0:
			if accel > self.lin_accel:
				out = current + self.lin_accel

		return out

	def wrap_angles(self, angle):
		# wrap between [-pi, pi]
		pi_2 = 2*np.pi
		angle = math.fmod(math.fmod(angle, pi_2) + pi_2, pi_2) 

		if angle > np.pi:
			angle -= 2*np.pi

		return angle
	
	def ControlHeading(self, waypoint):
		target_pos_local = self.transform2local(waypoint)
		target_position = target_pos_local.pose.position
		heading = np.arctan2(target_position.y, target_position.x)

		control_output = Twist()
		while (abs(heading) > self.yaw_tol):
			target_pos_local = self.transform2local(waypoint)
			target_position = target_pos_local.pose.position
			heading = np.arctan2(target_position.y, target_position.x)
			
			ang_vel = self.ang_controller.Calculate(0.1, heading, 0)
			lin_vel = 0

			control_output.angular.z, control_output.linear.x = ang_vel, lin_vel
			self.cmd_vel_pub.publish(control_output)

			self.rate.sleep()

		control_output.angular.z, control_output.linear.x = 0, 0
		self.cmd_vel_pub.publish(control_output)

	def ControlPosition(self, waypoint):
		target_pos_local = self.transform2local(waypoint)
		target_position = target_pos_local.pose.position
		error_mag = np.sqrt(target_position.x**2 + target_position.y**2)
		heading = np.arctan2(target_position.y, target_position.x)

		control_output = Twist()
		while (error_mag > self.pos_tol):	
			target_pos_local = self.transform2local(waypoint)
			target_position = target_pos_local.pose.position
			error_mag = np.sqrt(target_position.x**2 + target_position.y**2)

			heading = np.arctan2(target_position.y, target_position.x)

			if error_mag > 1.5*self.pos_tol:
				ang_vel = self.ang_controller.Calculate(0.01, heading, 0)
			else:
				ang_vel = 0
			
			lin_vel = self.lin_controller.Calculate(0.01, target_position.x, 0)

			control_output.angular.z = ang_vel
			lin_vel =  self.create_profile(lin_vel)

			control_output.angular.z, control_output.linear.x = ang_vel, lin_vel
			self.current_lin_vel = lin_vel
			self.cmd_vel_pub.publish(control_output)
			
			self.rate.sleep()

		control_output.angular.z, control_output.linear.x = 0, 0
		self.current_lin_vel = 0
		self.cmd_vel_pub.publish(control_output)

	def ControlOrient(self, waypoint):
		target_pos_local = self.transform2local(waypoint)
		target_orient = target_pos_local.pose.orientation
		quat = np.array([target_orient.x, target_orient.y, target_orient.z, target_orient.w])
	
		[_, _, yaw] = euler_from_quaternion(quat)
		yaw = self.wrap_angles(yaw)

		control_output = Twist()
		while (abs(yaw) > self.yaw_tol):
			target_pos_local = self.transform2local(waypoint)
			target_orient = target_pos_local.pose.orientation
			quat = np.array([target_orient.x, target_orient.y, target_orient.z, target_orient.w])
			
			[_, _, yaw] = euler_from_quaternion(quat)
			yaw = self.wrap_angles(yaw)
			
			ang_vel = self.ang_controller.Calculate(0.01, yaw, 0)
			lin_vel = 0

			control_output.angular.z, control_output.linear.x = ang_vel, lin_vel
			self.cmd_vel_pub.publish(control_output)

			self.rate.sleep()

		control_output.angular.z, control_output.linear.x = 0, 0
		self.cmd_vel_pub.publish(control_output)

	def Navigate(self, waypoint):	
		rospy.loginfo("Current Goal:")
		rospy.loginfo(waypoint)

		target= self.transform2local(waypoint)
		error_mag = np.sqrt(target.pose.position.x**2 + target.pose.position.y**2)
		if (error_mag > 3*self.pos_tol):
			self.ControlHeading(waypoint)
			self.ControlPosition(waypoint)

		self.ControlOrient(waypoint)


class Waypoint2D(MoveBaseGoal):
	def __init__(self, pos, orient):
		waypoint = PoseStamped()
			
		pos = Point(pos[0], pos[1], 0)
		orient = Quaternion(orient[0], orient[1], orient[2], orient[3])

		waypoint.pose.position, waypoint.pose.orientation = pos, orient
		self.target_pose = waypoint

class GridMap:
	class Direction(Enum):
		RIGHT, LEFT, BACKWARD, FORWARD = 0, 1, 2, 3

	class Cardinal(Enum):
		NORTH, EAST, SOUTH, WEST = 0, 1, 2, 3

		def CW(cardinal):
			return GridMap.Cardinal((cardinal.value + 1) % 4)

		def CCW(cardinal):
			return GridMap.Cardinal((cardinal.value - 1) % 4)

		def BACK(cardinal):
			return GridMap.Cardinal((cardinal.value + 2) % 4)

	# cardinal2quaternion lookup table
	# index with Cardinal (NESW) to get Quaternion
	card2quat = [(0, 0, 0, 1), 
			 	 (0, 0, -0.7071068, 0.7071068),
			 	 (0, 0, 1, 0),
			 	 (0, 0, 0.7071068, 0.7071068)]

	# maps a commanded direction + current orientation --> increments (x, y)
	# increment_map[Direction, Cardinal]  
	increment_map = [[( 0, 1), ( 1, 0), ( 0,-1), (-1, 0)],
				 	 [( 0,-1), (-1, 0), ( 0, 1), ( 1, 0)], 
				 	 [( 1, 0), ( 0,-1), (-1, 0), ( 0, 1)],
				 	 [(-1, 0), ( 0, 1), ( 1, 0), ( 0,-1)]]

	def __init__(self, init_pose, init_orient):
		#maxx = 3.3 maxy = 0.6
		self.GCx = np.linspace(3.3, 0.3, 6)
		self.GCy = np.linspace(0.6133, -0.6133, 3)
		#self.GCx = np.linspace(3.7, -0.75, 6)
		#self.GCy = np.linspace(0.9, -1, 3)
		self.GCx=np.matrix('3.7 3.7 3.71;2.8 2.72 2.85;1.78 1.8 2;0.81 .95 1.01;-.1 0.125 0.08;-0.86 -0.98 -0.98')
		self.GCy=np.matrix('1 -.3 -.9; 1.1 .077 -.95; .86 0 -.91; .92 .05 -1.04; .83 .076 -.96; .89 -.065 -1.05')

		self._localize(init_pose, init_orient)

	def _localize(self, init_pose, init_orient):
		init_pose = np.array(init_pose)
		init_orient = np.array(init_orient)

		# find location
		(mini, minj) = (0, 0)
		min_dist = 100
		for i in range(np.size(self.GCx,axis=0)):
			for j in range(np.size(self.GCy,axis=1)):
				pose = np.array([self.GCx[i,j], self.GCy[i,j]])
				norm = np.linalg.norm(pose - init_pose)
				if norm < min_dist:
					(mini, minj) = (i, j)
					min_dist = norm

		self.index = (mini, minj)

		# find orientation
		mini = 0
		min_dist = 100
		for i in range(len(GridMap.card2quat)):
			orient = np.array(GridMap.card2quat[i])
			
			norm = np.linalg.norm(orient - init_orient)
			if norm < min_dist:
				mini = i
				min_dist = norm

		self.dir = GridMap.Cardinal(mini)

	def update_index(self, direction):
		inc_x, inc_y = GridMap.increment_map[direction.value][self.dir.value]

		potential_x, potential_y = self.index
		potential_x += inc_x
		potential_y += inc_y

		# prevent overflow
		if (not np.size(self.GCx,axis=0) - potential_x <=0):
			self.index = (potential_x, self.index[1])
		if (not np.size(self.GCy,axis=1) - potential_y <=0):
			self.index = (self.index[0], potential_y)

	def globalpose(self):
		x = self.GCx[self.index[0],self.index[1]]
		y = self.GCy[self.index[0],self.index[1]]
		orient = GridMap.card2quat[self.dir.value]
		return ((x, y), orient)

	def right(self):
		#self.update_index(GridMap.Direction.RIGHT)
		self.dir = GridMap.Cardinal.CW(self.dir)

	def left(self):
		#self.update_index(GridMap.Direction.LEFT)
		self.dir = GridMap.Cardinal.CCW(self.dir)

	def forward(self):
		self.update_index(GridMap.Direction.FORWARD)

	def backward(self):
		self.update_index(GridMap.Direction.BACKWARD)
		self.dir = GridMap.Cardinal.BACK(self.dir)


class Lidar:
	def __init__(self):
		#self._twist = Twist()
		self.wall_status = 1

		self.lidar_sub = rospy.Subscriber("/scan", LaserScan, self.LidarCallback, queue_size=10)
		#self._vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size = 10)

	def LidarCallback(self, lidar_data):
		pause = False
		min_distance = self.parse_distances(lidar_data)
		self.wall_status = self.check_for_wall(min_distance)
		
		if pause:
			rospy.sleep(10)	

	def check_for_wall(self, min_distance, distance_thresh=0.8): #is there a wall or empty block in front of us?
		if min_distance>distance_thresh:
			wall_status = 0 #there is not a wall in front of us
		else:
			wall_status = 1 #there is a wall in front of us

		return wall_status

	def parse_distances(self, lidar_data, heading=0):
		HEADING_THRESH=10

	#		try:
		heading_range = np.array(range(int(heading) - HEADING_THRESH, 
									int(heading) + HEADING_THRESH + 1))

		## wrap angles
		lidar_ang = heading_range % 360		
		lidar_ang = (lidar_ang + 360) % 360 # force positive 

		lidar_ang = [ang-360 if ang > 180 else ang for ang in lidar_ang]

		dists = [lidar_data.ranges[i] for i in lidar_ang]
		filtered_dists=[]
		for point in dists:
			point = 1000 if point == 0 else point
			filtered_dists.append(point)

		min_dist = np.min(filtered_dists)

		return min_dist

class Executor:
	def __init__(self):
		self.lidar_sub = Lidar()

		# initialize map
		current_pos = rospy.wait_for_message("/amcl_pose", PoseWithCovarianceStamped)
		
		initpos = current_pos.pose.pose.position
		initorient = current_pos.pose.pose.orientation
		
		initpos = (initpos.x, initpos.y)
		initorient = (initorient.x, initorient.y, initorient.z, initorient.w)

		self.grid_map = GridMap(initpos, initorient)
		#print(self.grid_map.index)

		self.label_map = {0: 'empty_wall', 1: 'left', 2: 'right',
						  3: 'do not enter', 4: 'stop', 5: 'goal'}

		# create navigator
		ang_vel_min_max = (-BURGER_MAX_ANG_VEL, BURGER_MAX_ANG_VEL)
		lin_vel_min_max = (-BURGER_MAX_LIN_VEL, BURGER_MAX_LIN_VEL)
		self.nav = NavController(0.02, 0.034, ang_vel_min_max, lin_vel_min_max)

		self.goals_found = 0

	def execute(self):

		# check for wall
		rospy.sleep(1)
		if not self.lidar_sub.wall_status: # no wall
			self.grid_map.forward()
			pose, orient = self.grid_map.globalpose()
			waypoint = Waypoint2D(pose, orient)

			rospy.loginfo("============= Searching for sign ==============")

		else:
			rospy.sleep(3)
			sign_type = rospy.wait_for_message('/classified_image', Byte)
			sign_type = self.label_map[sign_type.data]

			rospy.loginfo("=============" + sign_type + "==============")

			if (sign_type == 'empty_wall'): 	 # try again next iteration
				waypoint = None
			else:								 # we found a sign
				if (sign_type == 'right'):
					self.grid_map.right()
				elif (sign_type == 'left'):
					self.grid_map.left()
				elif (sign_type == 'do not enter'):
					self.grid_map.backward()
				elif (sign_type == 'stop'):
					self.grid_map.backward()

				pose, orient = self.grid_map.globalpose()
				waypoint = Waypoint2D(pose, orient)

				if (sign_type == 'goal'):
					waypoint = None
					self.goals_found += 1
					rospy.loginfo('YOU DONT SUCK')
		
		if not waypoint == None:
			self.nav.Navigate(waypoint)
		
		return self.goals_found > 3
		
		
if __name__=='__main__':
	rospy.init_node('navigate_maze_final', anonymous=False)

	try:
		exec_test = Executor()

		while (not rospy.is_shutdown()):
			goal_found = exec_test.execute()

			if goal_found:
				break

	except rospy.ROSInterruptException:
		pass