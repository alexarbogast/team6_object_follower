#!/usr/bin/env python

############################################################
# navigate_map node: moves the turtle bot to waypoints 
# while navigating through map 
############################################################

from operator import index
import rospy
import numpy as np
import actionlib

from enum import Enum

from geometry_msgs.msg import PoseStamped, Point, Quaternion
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from actionlib_msgs.msg import GoalStatus
from sensor_msgs.msg import LaserScan

class Navigator:
	def __init__(self):
		self.move_base = actionlib.SimpleActionClient('move_base', MoveBaseAction)
		self.move_base.wait_for_server()

	def _SetHeader(self, goal):
		goal.target_pose.header.stamp = rospy.Time.now()
		goal.target_pose.header.frame_id = "map"
		return goal

	def Navigate(self, waypoint):
		current_waypoint = self._SetHeader(waypoint)
		
		rospy.loginfo("Current Goal:")
		rospy.loginfo(current_waypoint)
		
		self.move_base.send_goal(current_waypoint)	
		success = self.move_base.wait_for_result(rospy.Duration(60))
		state = self.move_base.get_state()
		
		if success and state == GoalStatus.SUCCEEDED:
			rospy.loginfo(self.move_base.get_goal_status_text)
		else:
			rospy.loginfo(self.move_base.get_goal_status_text)
			self.move_base.cancel_goal()
			rospy.logerr("Did not reach goal... exiting")
		
		return success

class Waypoint2D(MoveBaseGoal):
	def __init__(self, pos, orient):
		waypoint = PoseStamped()
			
		pos = Point(pos[0], pos[1], 0)
		orient = Quaternion(orient[0], orient[1], orient[2], orient[3])

		waypoint.pose.position, waypoint.pose.orientation = pos, orient
		self.target_pose = waypoint


class GridMap:
	class Direction(Enum):
		RIGHT, LEFT, BACKWARD, FORWARD = 0, 1, 2, 3

	class Cardinal(Enum):
		NORTH, EAST, SOUTH, WEST = 0, 1, 2, 3

		def CW(cardinal):
			return GridMap.Cardinal((cardinal.value + 1) % 4)

		def CCW(cardinal):
			return GridMap.Cardinal((cardinal.value - 1) % 4)

		def BACK(cardinal):
			return GridMap.Cardinal((cardinal.value + 2) % 4)

	# cardinal2quaternion lookup table
	# index with Cardinal (NSEW) to get Quaternion
	card2quat = [(0, 0, 0, 1), 
			 	 (0, 0, -0.7071068, 0.7071068),
			 	 (0, 0, 1, 0),
			 	 (0, 0, 0.7071068, 0.7071068)]

	# maps a commanded direction + current orientation --> increments (x, y)
	# increment_map[Direction, Cardinal]  
	increment_map = [[( 0, 1), ( 1, 0), ( 0,-1), (-1, 0)],
				 	 [( 0,-1), (-1, 0), ( 0, 1), ( 1, 0)], 
				 	 [( 1, 0), ( 0,-1), (-1, 0), ( 0, 1)],
				 	 [(-1, 0), ( 0, 1), ( 1, 0), ( 0,-1)]]

	def __init__(self, init_pose):
		#maxx = 3.3 maxy = 0.6
		self.GCx = np.linspace(3.3, 0.3, 6)
		self.GCy = np.linspace(0.6, -0.6, 3)

		self.index = (0, 0)
		self.dir = GridMap.Cardinal.SOUTH

	def update_index(self, direction):
		inc_x, inc_y = GridMap.increment_map[direction.value][self.dir.value]

		potential_x, potential_y = self.index
		potential_x += inc_x
		potential_y += inc_y

		# prevent overflow
		if (not np.size(self.GCx) - potential_x <=0):
			self.index = (potential_x, self.index[1])
		if (not np.size(self.GCy) - potential_y <=0):
			self.index = (self.index[0], potential_y)

	def globalpose(self):
		x = self.GCx[self.index[0]]
		y = self.GCy[self.index[1]]
		orient = GridMap.card2quat[self.dir.value]
		return ((x, y), orient)

	def right(self):
		#self.update_index(GridMap.Direction.RIGHT)
		self.dir = GridMap.Cardinal.CW(self.dir)

	def left(self):
		#self.update_index(GridMap.Direction.LEFT)
		self.dir = GridMap.Cardinal.CCW(self.dir)

	def forward(self):
		self.update_index(GridMap.Direction.FORWARD)

	def backward(self):
		self.update_index(GridMap.Direction.BACKWARD)
		self.dir = GridMap.Cardinal.BACK(self.dir)

class Lidar:
	def __init__(self):

		#self._twist = Twist()
		self.wall_status = 1

		self.lidar_sub = rospy.Subscriber("/scan", LaserScan, self.LidarCallback, queue_size=10)
		#self._vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size = 10)

	def LidarCallback(self, lidar_data):
		pause = False
		min_distance = self.parse_distances(lidar_data)
		self.wall_status = self.check_for_wall(min_distance)
		
		if pause:
			rospy.sleep(10)	

	def check_for_wall(self, min_distance, distance_thresh=0.5): #is there a wall or empty block in front of us?
		if min_distance>distance_thresh:
			wall_status = 0 #there is not a wall in front of us
		else:
			wall_status = 1 #there is a wall in front of us

		return wall_status

	def parse_distances(self, lidar_data, heading=0):
		HEADING_THRESH=10

	#		try:
		heading_range = np.array(range(int(heading) - HEADING_THRESH, 
									int(heading) + HEADING_THRESH + 1))

		## wrap angles
		lidar_ang = heading_range % 360		
		lidar_ang = (lidar_ang + 360) % 360 # force positive 

		lidar_ang = [ang-360 if ang > 180 else ang for ang in lidar_ang]

		dists = [lidar_data.ranges[i] for i in lidar_ang]
		filtered_dists=[]
		for point in dists:
			point = 1000 if point == 0 else point
			filtered_dists.append(point)

		min_dist = np.min(filtered_dists)

		return min_dist

if __name__=='__main__':
	rospy.init_node('navigate_maze_final', anonymous=False)

	nav = Navigator()
	map = GridMap(5)

	try:
		# example series of waypoints
		map.forward()
		pose, orient = map.globalpose()

		way = Waypoint2D(pose, orient)
		rospy.loginfo("Traveling to: " + str(way.target_pose))
		nav.Navigate(way)

		map.left()
		map.forward()
		pose, orient = map.globalpose()

		way = Waypoint2D(pose, orient)
		rospy.loginfo("Traveling to: " + str(way.target_pose))
		nav.Navigate(way)

		map.forward()
		pose, orient = map.globalpose()

		way = Waypoint2D(pose, orient)
		rospy.loginfo("Traveling to: " + str(way.target_pose))
		nav.Navigate(way)
	except rospy.ROSInterruptException:
		pass